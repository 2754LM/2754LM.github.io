---
layout: blog
title: 扫描线实现
date: 2024-03-07 10:23:15
tags:
- 数据结构
categories:
- 数据结构
- 线段树
- 扫描线
---

# 离散化

先讲一下线段树的离散化问题,如果直接按出现位次来离散的话会有问题

比如1,50,100,150离散成了1,2,3,4.如果我们覆盖了1-2和3-4,看上去是全部覆盖了,但实际上50-10这个区间我们并没有覆盖到.

有两种解决方法,1:不连续的树中间再插入一个数,2:进行右偏

1:

如1,50,51,100,150.离散化为1(1),2,3(50),4(51),5,6(100),7,8(150)

2:

右偏即区间[l,r]原来是算[x~l~,y~r~]变成了[x~l~,y~r+1~]

1,50,100,150离散化为1,2,3.根据定义得出4是无意义的

在传参的时候,我们需要右端点左偏,计算时右端点右偏.即区间[1,3]传入[1,2],计算[1,3]

其实还有一种方法,可以省去一-1的操作,就是区间定义改成左闭右开,这样传值和计算直接正常r就可以了(自己想一下为什么)

# 扫描线

[模板题](https://www.luogu.com.cn/problem/P5490)

两种方向实现,从左到右和从下到上.

基本的定义,下文以从下到上来实现,感觉闭区间更好写,可以看下面的下面代码

<!-- more -->

## 左开右闭

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
typedef long long ll;
const ll N = 8e5 + 5; 
ll ls(ll x){
	return x * 2;
}
ll rs(ll x){
	return x * 2 + 1;
}
ll tag[N];  //区间覆盖次数
ll len[N];  //区间覆盖长度
ll xx[N]; //yy[N],离散化
//如果是横向的
struct scanline{
    ll x1, x2, y, io; //线段起点终点高,和出入边记录
    bool operator< (const scanline & a)const{
        return y < a.y;  //从低到高排扫描线
    }
    
}line[N];
//如果是纵向的
//struct scanline{
//    int y1, y2, x, io;
//    bool operator< (const scanline & a)const{
//        return x < a.x;
//    }
//}line[N];
void push_up(int p, int pl, int pr){
    if(tag[p]) len[p] = xx[pr] - xx[pl]; //隐式右偏
    else if(pl + 1 == pr) len[p] = 0; //特判,如果不写这个就要开8n空间,让叶子也有儿子
    else{
        len[p] = len[ls(p)] + len[rs(p)];
    }
}
void update(int p, int io, int pl, int pr, int l, int r){
    //*特判if(l >= pr || r <= pl) return;
    //p是当前节点,io出入边判断,plpr区间起终点,lr查询区间
    if(l <= pl && pr <= r){ //覆盖区间,这里r必须是>=
        tag[p] += io;
        push_up(p, pl, pr);
        return;
    }
    if(pl + 1 == pr) return; //叶子节点,左闭右开写法必加,不然死循环哩
    //这里要特判,比如pl = 1, pr = 2, mid = 1;传入下一层一个是[1,1]一个是[1,2].死循环,主要还是一些细节处理的问题
    //如果这里用双闭区间就没这个问题,因为你传的mid-1和mid
    //其实这句话也可以不写,只要你在开头加个判断见*处
    ll mid = (pl + pr) / 2;
    if(l <= mid){
        update(ls(p), io, pl, mid, l, r);
    }
    if(r > mid){ //这里>=也可以,因为r - mid必定大于等于1
        update(rs(p), io, mid, pr, l, r);
    }
    push_up(p, pl, pr);
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	ll n;
	cin>>n;
	ll cnt = 0;
	for(ll i = 0; i < n; i++){
		ll x1,y1,x2,y2;
		cin>>x1>>y1>>x2>>y2;
		line[++cnt] = {x1, x2, y1, 1}; //入边 
		xx[cnt] = x1;
		line[++cnt] = {x1, x2, y2, -1}; //出边 
		xx[cnt] = x2;
	} 
    sort(line + 1, line + 1 + cnt); 
	sort(xx + 1, xx + 1 + cnt);//离散化
	ll m = unique(xx+1, xx+1+cnt) - (xx+1);  //去重
	ll ans = 0;
	for(int i = 1; i <= cnt; i++){
		ans += len[1] * (line[i].y - line[i-1].y); //区间长度x高度
		ll l = lower_bound(xx + 1, xx + 1 + m, line[i].x1) - xx;
		ll r = lower_bound(xx + 1, xx + 1 + m, line[i].x2) - xx;
		update(1, line[i].io, 1, m, l, r);
	}
	cout<<ans<<endl;
	return 0;
}
```

## 闭区间
我又重新写了一遍,发现闭区间反而更好理解,在有更改的地方我加注释

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
typedef long long ll;
const ll N = 1e5 * 6 + 5; //开4倍竟然过不了这题,哦哦哦,因为线段起点终点是两个点,要8n空间,6n能过是数据问题

ll ls(ll x){return x * 2;}
ll rs(ll x){return x * 2 + 1;}
ll tag[N];
ll len[N];
ll xx[N];
struct scanline{
    ll x1, x2, y, io;
    bool operator< (const scanline & a)const{
        return y < a.y;
    }
}line[N];

void push_up(ll p, ll pl, ll pr){
	if(tag[p]) len[p] = xx[pr + 1] - xx[pl]; //这里是pr+1 
	else if(pl == pr) len[p] = 0;  //这样就不用开8n空间啦,直接特判叶子节点
	else len[p] = len[ls(p)] + len[rs(p)]; 
}

void update(ll p, ll io, ll pl, ll pr, ll l, ll r){
//	if(l > pr || r < pl) return; 这个特判在这里是可有可无的, 因为下面我都判好了
    if(l <= pl && pr <= r){ 
        tag[p] += io;
        push_up(p, pl, pr);
        return;
    }
    ll mid = (pl + pr) / 2;
    if(l <= mid)	update(ls(p), io, pl, mid, l, r);
    if(r > mid)		update(rs(p), io, mid + 1, pr, l, r);
    push_up(p, pl, pr);
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	ll n;
	cin>>n;
	ll cnt = 0;
	for(int i = 0; i < n; i++){
		ll x1,y1,x2,y2;
		cin>>x1>>y1>>x2>>y2;
		line[++cnt] = {x1, x2, y1, 1};
		xx[cnt] = x1;
		line[++cnt] = {x1, x2, y2, -1};
		xx[cnt] = x2;
	}
    sort(line + 1, line + 1 + cnt); 
	sort(xx + 1, xx + 1 + cnt);
	ll m = unique(xx+1, xx+1+cnt) - (xx+1); 
	ll ans = 0;
	for(int i = 1; i <= cnt; i++){
		ans += len[1] * (line[i].y - line[i-1].y);
		ll l = lower_bound(xx + 1, xx + 1 + m, line[i].x1) - xx;
		ll r = lower_bound(xx + 1, xx + 1 + m, line[i].x2) - xx;
		update(1, line[i].io, 1, m-1, l, r-1);  //这里传r-1,m-1和m随便传,m是不会包括到的
	}
	cout<<ans<<endl;
	return 0;
}
```
