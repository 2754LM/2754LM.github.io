---
title: 数论
categories:
- 算法
- 数论
tags:
- 算法
---



# 辗转相除法

我们将两数中较大的那一个看作是被除数A，将较小的那一个看作是除数B，二者相除的商记作C，余数记作D。这样我们就可以得到一个等式：A = B×C + D。而辗转相除法的所要用到的原理则是：(A , B) = (B , D)。

（m，n)表示m%n,直到（ ， ）=0，则最后的余数为两个数的最大公因数。

<!-- more -->



# 最小公倍数

n和m的乘积除以最大公约数=最小公倍数

# 快速幂

> 取模
>
> (a + b) % p = (a % p + b % p) % p
> (a - b) % p = (a % p - b % p ) % p
> **(a \* b) % p = (a % p \* b % p) % p**

快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算

3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)

3^10=(3*3)^5

3^10=9^5

//现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5

9^5=（9^4）*（9^1）

```cpp
long long fastPower(long long base, long long power) {
 long long result = 1;
 while (power > 0) {
     if (power % 2 == 0) {
         //如果指数为偶数
         power = power / 2;//把指数缩小为一半
         base = base * base % 1000;//底数变大成原来的平方
     } else {
         //如果指数为奇数
         power = power - 1;//把指数减去1，使其变成一个偶数
         result = result * base % 1000;//此时记得要把指数为奇数时分离出来的底数的一次方收集好
         power = power / 2;//此时指数为偶数，可以继续执行操作
         base = base * base % 1000;
     }
 }
 return result;
}

long long fastPower(long long base, long long power) {
 long long result = 1;
 while (power > 0) {
     if (power % 2 == 1) {
         result = result * base % 1000;
     }
     power = power / 2;
     base = (base * base) % 1000;
 }
 return result;
}
```



